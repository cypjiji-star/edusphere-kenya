rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to check user roles from their auth token
    function isDeveloper() {
      return request.auth.token.role == 'developer';
    }

    function isSchoolAdmin(schoolId) {
      return request.auth.token.schoolId == schoolId && request.auth.token.role == 'admin';
    }

    function isTeacher(schoolId) {
      return request.auth.token.schoolId == schoolId && request.auth.token.role == 'teacher';
    }

    function isParent(schoolId) {
        return request.auth.token.schoolId == schoolId && request.auth.token.role == 'parent';
    }

    function isSignedIn(schoolId) {
      return request.auth != null && request.auth.token.schoolId == schoolId;
    }

    // Allow developers to read/write anything in the database.
    // This rule is checked first. If a user is a developer, they pass.
    match /{document=**} {
      allow read, write: if isDeveloper();
    }
    
    // Allow public read access for school profiles (for login page branding)
    match /schoolProfile/{profileId} {
      allow read: if true;
      allow write: if isDeveloper() || isSchoolAdmin(profileId); // Only admins of that school or devs can write
    }

    // Rules for school-specific data. All paths are nested under /schools/{schoolId}.
    // This is the core of the multi-tenant security model.
    match /schools/{schoolId} {
      // Allow any signed-in user of a school to read the main school document.
      allow read: if isSignedIn(schoolId);
      // Only admins of that school can update the main school document.
      allow update: if isSchoolAdmin(schoolId);

      // --- Nested Subcollections ---

      // Students & their subcollections (grades, attendance, etc.)
      match /students/{studentId} {
        allow read: if isTeacher(schoolId); // Teachers can read student profiles
        allow write: if isSchoolAdmin(schoolId); // Admins can create/edit students

        // Parents can only read their own child's data
        allow read: if isParent(schoolId) && studentId in get(/databases/$(database)/documents/users/$(request.auth.uid)).data.children;
      }
      
      // Allow all authenticated users of a school to read teachers and classes
      match /users/{userId} {
        allow read: if isSignedIn(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }

      match /classes/{classId} {
        allow read: if isSignedIn(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }
      
      // Assignments, Attendance, etc.
      // Teachers can create/read/update their own, Admins have full access.
      match /assignments/{assignmentId} {
        allow read: if isTeacher(schoolId);
        allow create, update: if isTeacher(schoolId) && request.resource.data.teacherId == request.auth.uid;
        allow delete, update: if isSchoolAdmin(schoolId);
      }
      
       match /attendance/{attendanceId} {
        allow read: if isTeacher(schoolId);
        allow create, update: if isTeacher(schoolId) && request.resource.data.teacherId == request.auth.uid;
        allow delete, update: if isSchoolAdmin(schoolId);
      }

      // Generic rule for most other school-specific collections
      match /{collection}/{docId} {
        allow read: if isSignedIn(schoolId);
        allow write: if isSchoolAdmin(schoolId) || isTeacher(schoolId); // Allow teachers to write to other collections if needed
      }
    }
    
    // Deny all other reads/writes by default.
    // This is implicitly handled by having no general "allow" rule.
  }
}
